import { SupabaseClient } from '@supabase/supabase-js'
  // =====================================================
  // Types
  // =====================================================
  export type TrainingSchedule = {
    id?: string
    team_id: string
    day_of_week: number  // 0=Dom, 1=Lun, ..., 6=Sab
    start_time: string   // "18:00:00" o "18:00"
    end_time: string     // "20:00:00" o "20:00"
    gym_id: string
    is_active?: boolean
  }
  type Season = {
    id: string
    end_date: string
  }
  type Team = {
    id: string
    name: string
    activity_id: string
  }
  type Gym = {
    id: string
    name: string
    city?: string
  }
  // =====================================================
  // Funzione principale: genera eventi ricorrenti da template
  // =====================================================
  export async function generateTrainingEventsFromSchedules(
    teamId: string,
    schedules: TrainingSchedule[],
    supabase: SupabaseClient
  ): Promise<{ success: boolean; error?: string; eventsCreated?: number }> {
    try {
      // 1. Ottieni info squadra
      const { data: team, error: teamError } = await supabase
        .from('teams')
        .select('id, name, activity_id, is_active')
        .eq('id', teamId)
        .single()
      if (teamError || !team) {
        return { success: false, error: 'Squadra non trovata' }
      }
      // Se la squadra non è attiva, non generare eventi
      if (!team.is_active) {
        return { success: true, eventsCreated: 0 }
      }
      // 2. Ottieni fine stagione
      const seasonEndDate = await getSeasonEndDate(team.activity_id, supabase)
      if (!seasonEndDate) {
        return { success: false, error: 'Nessuna stagione attiva trovata' }
      }
      // Verifica che la stagione non sia già conclusa
      if (new Date(seasonEndDate) < new Date()) {
        return {
          success: false,
          error: 'La stagione è già conclusa. Impossibile generare eventi futuri.'
        }
      }
      // 3. Cancella eventi training ricorrenti esistenti creati automaticamente
      // (mantieni quelli modificati manualmente)
      await deleteExistingAutoGeneratedTrainingEvents(teamId, supabase)
      // 4. Filtra solo schedules attivi
      const activeSchedules = schedules.filter(s => s.is_active !== false)
      if (activeSchedules.length === 0) {
        return { success: true, eventsCreated: 0 }
      }
      // 5. Genera eventi per ogni schedule
      let eventsCreated = 0
      for (const schedule of activeSchedules) {
        // Ottieni info palestra per location
        const { data: gym } = await supabase
          .from('gyms')
          .select('id, name, city')
          .eq('id', schedule.gym_id)
          .single()
        if (!gym) continue
        // Calcola la prima data valida per questo giorno della settimana
        const firstDate = getNextDateForDayOfWeek(schedule.day_of_week)
        // Componi start_date e end_date (combina data + time)
        const startDateTime = combineDateAndTime(firstDate, schedule.start_time)
        const endDateTime = combineDateAndTime(firstDate, schedule.end_time)
        // Componi recurrence_end_date (fine giornata della stagione)
        const recurrenceEndDateTime = new Date(seasonEndDate)
        recurrenceEndDateTime.setHours(23, 59, 59, 999)
        // Ottieni l'utente corrente per created_by
        const { data: { user } } = await supabase.auth.getUser()
        if (!user) {
          console.error('Utente non autenticato')
          continue
        }

        const eventTitle = `Allenamento ${team.name}`
        const eventLocation = gym.city ? `${gym.name}, ${gym.city}` : gym.name

        // Crea evento ricorrente
        const { data: newEvent, error: eventError } = await supabase
          .from('events')
          .insert({
            name: eventTitle,  // Campo obbligatorio
            title: eventTitle,
            description: `Allenamento settimanale - ${getDayName(schedule.day_of_week)}`,
            start_date: startDateTime.toISOString(),
            end_date: endDateTime.toISOString(),
            start_time: startDateTime.toISOString(),  // Campo obbligatorio (sembra duplicato)
            end_time: endDateTime.toISOString(),      // Campo obbligatorio (sembra duplicato)
            location: eventLocation,
            gym_id: gym.id,
            activity_id: team.activity_id,
            event_type: 'recurring',
            event_kind: 'training',
            recurrence_rule: { frequency: 'weekly', interval: 1 },
            recurrence_end_date: recurrenceEndDateTime.toISOString(),
            parent_event_id: null,  // Questo è il parent
            created_by: user.id,    // Campo obbligatorio
            requires_confirmation: false,
          })
          .select('id')
          .single()
        if (eventError) {
          console.error('Errore creazione evento:', eventError)
          continue
        }
        // Collega evento alla squadra
        await supabase
          .from('event_teams')
          .insert({
            event_id: newEvent.id,
            team_id: teamId,
          })
        eventsCreated++
      }
      return {
        success: true,
        eventsCreated,
      }
    } catch (error) {
      console.error('Errore in generateTrainingEventsFromSchedules:', error)
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Errore sconosciuto'
      }
    }
  }
  // =====================================================
  // Helper: Ottieni fine stagione
  // =====================================================
  async function getSeasonEndDate(
    activityId: string,
    supabase: SupabaseClient
  ): Promise<string | null> {
    const { data: activity } = await supabase
      .from('activities')
      .select('season_id')
      .eq('id', activityId)
      .single()
    if (!activity?.season_id) return null
    const { data: season } = await supabase
      .from('seasons')
      .select('end_date, is_active')
      .eq('id', activity.season_id)
      .eq('is_active', true)
      .single()
    return season?.end_date || null
  }
  // =====================================================
  // Helper: Cancella eventi training auto-generati esistenti
  // =====================================================
  async function deleteExistingAutoGeneratedTrainingEvents(
    teamId: string,
    supabase: SupabaseClient
  ): Promise<void> {
    // Trova tutti gli eventi training ricorrenti per questa squadra
    // che sono "parent" (non istanze modificate)
    const { data: eventTeams } = await supabase
      .from('event_teams')
      .select('event_id')
      .eq('team_id', teamId)
    if (!eventTeams || eventTeams.length === 0) return
    const eventIds = eventTeams.map(et => et.event_id)
    // Cancella eventi che sono:
    // - training
    // - recurring
    // - parent (parent_event_id IS NULL)
    // NOTA: Non cancelliamo istanze modificate manualmente (parent_event_id NOT NULL)
    await supabase
      .from('events')
      .delete()
      .in('id', eventIds)
      .eq('event_kind', 'training')
      .eq('event_type', 'recurring')
      .is('parent_event_id', null)
    // event_teams verrà cancellato automaticamente per CASCADE
  }
  // =====================================================
  // Helper: Calcola prossima data per giorno della settimana
  // =====================================================
  function getNextDateForDayOfWeek(
    targetDayOfWeek: number, 
    afterDate: Date = new Date()
  ): Date {
    const result = new Date(afterDate)
    const currentDay = result.getDay()
    let daysToAdd = targetDayOfWeek - currentDay
    // Se il giorno è già passato questa settimana, vai alla prossima
    if (daysToAdd <= 0) {
      daysToAdd += 7
    }
    result.setDate(result.getDate() + daysToAdd)
    return result
  }
  // =====================================================
  // Helper: Combina data e time
  // =====================================================
  function combineDateAndTime(date: Date, timeString: string): Date {
    // timeString può essere "18:00:00" o "18:00"
    const [hours, minutes] = timeString.split(':').map(Number)
    const result = new Date(date)
    result.setHours(hours, minutes, 0, 0)
    return result
  }
  // =====================================================
  // Helper: Nome del giorno in italiano
  // =====================================================
  function getDayName(dayOfWeek: number): string {
    const days = ['Domenica', 'Lunedì', 'Martedì', 'Mercoledì', 'Giovedì', 'Venerdì', 'Sabato']
    return days[dayOfWeek] || 'Giorno non valido'
  }
  // =====================================================
  // Helper: Verifica conflitti palestra (per UI warnings)
  // =====================================================
  export type GymConflict = {
    teamName: string
    startTime: string
    endTime: string
  }
  export async function checkGymScheduleConflicts(
    gymId: string,
    dayOfWeek: number,
    startTime: string,
    endTime: string,
    excludeScheduleId?: string,
    supabase?: SupabaseClient
  ): Promise<GymConflict[]> {
    if (!supabase) return []
    // Usa la funzione SQL se disponibile, altrimenti query diretta
    try {
      const { data, error } = await supabase.rpc('check_gym_schedule_conflicts', {
        p_gym_id: gymId,
        p_day_of_week: dayOfWeek,
        p_start_time: startTime,
        p_end_time: endTime,
        p_exclude_schedule_id: excludeScheduleId || null,
      })
      if (error) throw error
      return data?.map((row: any) => ({
        teamName: row.team_name,
        startTime: row.conflict_start,
        endTime: row.conflict_end,
      })) || []
    } catch (error) {
      console.error('Errore check conflitti:', error)
      return []
    }
  }
