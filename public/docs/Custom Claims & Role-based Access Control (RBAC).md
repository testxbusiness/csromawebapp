# Custom Claims & Role-based Access Control (RBAC)

---

Custom Claims are special attributes attached to a user that you can use to control access to portions of your application. For example:

{  
 "user\_role": "admin",  
 "plan": "TRIAL",  
 "user\_level": 100,  
 "group\_name": "Super Guild\!",  
 "joined\_on": "2022-05-20T14:28:18.217Z",  
 "group\_manager": false,  
 "items": \["toothpick", "string", "ring"\]  
}

To implement Role-Based Access Control (RBAC) with custom claims, use a [Custom Access Token Auth Hook](https://supabase.com/docs/guides/auth/auth-hooks#hook-custom-access-token). This hook runs before a token is issued. You can use it to add additional claims to the user's JWT.

This guide uses the [Slack Clone example](https://github.com/supabase/supabase/tree/master/examples/slack-clone/nextjs-slack-clone) to demonstrate how to add a user\_role claim and use it in your [Row Level Security (RLS) policies](https://supabase.com/docs/guides/database/postgres/row-level-security).

## Create a table to track user roles and permissions[\#](https://supabase.com/docs/guides/database/postgres/custom-claims-and-role-based-access-control-rbac?utm_source=youtube&utm_medium=video&utm_campaign=youtube&utm_content=kwokmi6inaw#create-a-table-to-track-user-roles-and-permissions)

In this example, you will implement two user roles with specific permissions:

* moderator: A moderator can delete all messages but not channels.  
* admin: An admin can delete all messages and channels.

*\-- Custom types*  
create type public.app\_permission as enum ('channels.delete', 'messages.delete');  
create type public.app\_role as enum ('admin', 'moderator');  
*\-- USER ROLES*  
create table public.user\_roles (  
 id        bigint generated by default as identity primary key,  
 user\_id   uuid references auth.users on delete cascade not null,  
 role      app\_role not null,  
 unique (user\_id, role)  
);  
comment on table public.user\_roles is 'Application roles for each user.';  
*\-- ROLE PERMISSIONS*  
create table public.role\_permissions (  
 id           bigint generated by default as identity primary key,  
 role         app\_role not null,  
 permission   app\_permission not null,  
 unique (role, permission)  
);  
comment on table public.role\_permissions is 'Application permissions for each role.';  
For the [full schema](https://github.com/supabase/supabase/blob/master/examples/slack-clone/nextjs-slack-clone/README.md), see the example application on [GitHub](https://github.com/supabase/supabase/tree/master/examples/slack-clone/nextjs-slack-clone).

You can now manage your roles and permissions in SQL. For example, to add the mentioned roles and permissions from above, run:

insert into public.role\_permissions (role, permission)  
values  
 ('admin', 'channels.delete'),  
 ('admin', 'messages.delete'),  
 ('moderator', 'messages.delete');

## Create Auth Hook to apply user role[\#](https://supabase.com/docs/guides/database/postgres/custom-claims-and-role-based-access-control-rbac?utm_source=youtube&utm_medium=video&utm_campaign=youtube&utm_content=kwokmi6inaw#create-auth-hook-to-apply-user-role)

The [Custom Access Token Auth Hook](https://supabase.com/docs/guides/auth/auth-hooks#hook-custom-access-token) runs before a token is issued. You can use it to edit the JWT.

PL/pgSQL (best performance)

*\-- Create the auth hook function*

create or replace function public.custom\_access\_token\_hook(event jsonb)

returns jsonb

language plpgsql

stable

as $$

 declare

   claims jsonb;

   user\_role public.app\_role;

 begin

   *\-- Fetch the user role in the user\_roles table*

   select role into user\_role from public.user\_roles where user\_id \= (event-\>\>'user\_id')::uuid;

   claims :\= event-\>'claims';

   if user\_role is not null then

     *\-- Set the claim*

     claims :\= jsonb\_set(claims, '{user\_role}', to\_jsonb(user\_role));

   else

     claims :\= jsonb\_set(claims, '{user\_role}', 'null');

   end if;

   *\-- Update the 'claims' object in the original event*

   event :\= jsonb\_set(event, '{claims}', claims);

   *\-- Return the modified or original event*

   return event;

 end;

$$;

grant usage on schema public to supabase\_auth\_admin;

grant execute

 on function public.custom\_access\_token\_hook

 to supabase\_auth\_admin;

revoke execute

 on function public.custom\_access\_token\_hook

 from authenticated, anon, public;

grant all

 on table public.user\_roles

to supabase\_auth\_admin;

revoke all

 on table public.user\_roles

 from authenticated, anon, public;

create policy "Allow auth admin to read user roles" ON public.user\_roles

as permissive for select

to supabase\_auth\_admin

using (true)

### Enable the hook[\#](https://supabase.com/docs/guides/database/postgres/custom-claims-and-role-based-access-control-rbac?utm_source=youtube&utm_medium=video&utm_campaign=youtube&utm_content=kwokmi6inaw#enable-the-hook)

In the dashboard, navigate to [Authentication \> Hooks (Beta)](https://supabase.com/dashboard/project/_/auth/hooks) and select the appropriate Postgres function from the dropdown menu.

When developing locally, follow the [local development](https://supabase.com/docs/guides/auth/auth-hooks#local-development) instructions.

To learn more about Auth Hooks, see the [Auth Hooks docs](https://supabase.com/docs/guides/auth/auth-hooks).

## Accessing custom claims in RLS policies[\#](https://supabase.com/docs/guides/database/postgres/custom-claims-and-role-based-access-control-rbac?utm_source=youtube&utm_medium=video&utm_campaign=youtube&utm_content=kwokmi6inaw#accessing-custom-claims-in-rls-policies)

To utilize Role-Based Access Control (RBAC) in Row Level Security (RLS) policies, create an authorize method that reads the user's role from their JWT and checks the role's permissions:

create or replace function public.authorize(  
 requested\_permission app\_permission  
)  
returns boolean as $$  
declare  
 bind\_permissions int;  
 user\_role public.app\_role;  
begin  
 *\-- Fetch user role once and store it to reduce number of calls*  
 select (auth.jwt() \-\>\> 'user\_role')::public.app\_role into user\_role;  
 select count(\*)  
 into bind\_permissions  
 from public.role\_permissions  
 where role\_permissions.permission \= requested\_permission  
   and role\_permissions.role \= user\_role;  
 return bind\_permissions \> 0;  
end;  
$$ language plpgsql stable security definer set search\_path \= '';  
You can read more about using functions in RLS policies in the [RLS guide](https://supabase.com/docs/guides/database/postgres/row-level-security#using-functions).

You can then use the authorize method within your RLS policies. For example, to enable the desired delete access, you would add the following policies:

create policy "Allow authorized delete access" on public.channels for delete to authenticated using ( (SELECT authorize('channels.delete')) );  
create policy "Allow authorized delete access" on public.messages for delete to authenticated using ( (SELECT authorize('messages.delete')) );

## Accessing custom claims in your application[\#](https://supabase.com/docs/guides/database/postgres/custom-claims-and-role-based-access-control-rbac?utm_source=youtube&utm_medium=video&utm_campaign=youtube&utm_content=kwokmi6inaw#accessing-custom-claims-in-your-application)

The auth hook will only modify the access token JWT but not the auth response. Therefore, to access the custom claims in your application, e.g. your browser client, or server-side middleware, you will need to decode the access\_token JWT on the auth session.

In a JavaScript client application you can for example use the [jwt-decode package](https://www.npmjs.com/package/jwt-decode):

import { jwtDecode } from 'jwt-decode'  
const { subscription: authListener } \= supabase.auth.onAuthStateChange(async (event, session) \=\> {  
 if (session) {  
   const jwt \= jwtDecode(session.access\_token)  
   const userRole \= jwt.user\_role  
 }  
})

For server-side logic you can use packages like [express-jwt](https://github.com/auth0/express-jwt), [koa-jwt](https://github.com/stiang/koa-jwt), [PyJWT](https://github.com/jpadilla/pyjwt), [dart\_jsonwebtoken](https://pub.dev/packages/dart_jsonwebtoken), [Microsoft.AspNetCore.Authentication.JwtBearer](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.JwtBearer), etc.

# Auth Hooks

## Use HTTP or Postgres Functions to customize your authentication flow

---

## What is a hook[\#](https://supabase.com/docs/guides/auth/auth-hooks#what-is-a-hook)

A hook is an endpoint that allows you to alter the default Supabase Auth flow at specific execution points. Developers can use hooks to add custom behavior that's not supported natively.

Hooks help you:

* Track the origin of user signups by adding metadata  
* Improve security by adding additional checks to password and multi-factor authentication  
* Support legacy systems by integrating with identity credentials from external authentication systems  
* Add additional custom claims to your JWT  
* Send authentication emails or SMS messages through a custom provider

The following hooks are available:

| Hook | Available on Plan |
| ----- | ----- |
| [Before User Created](https://supabase.com/docs/guides/auth/auth-hooks/before-user-created-hook) | Free, Pro |
| [Custom Access Token](https://supabase.com/docs/guides/auth/auth-hooks/custom-access-token-hook) | Free, Pro |
| [Send SMS](https://supabase.com/docs/guides/auth/auth-hooks/send-sms-hook) | Free, Pro |
| [Send Email](https://supabase.com/docs/guides/auth/auth-hooks/send-email-hook) | Free, Pro |
| [MFA Verification Attempt](https://supabase.com/docs/guides/auth/auth-hooks/mfa-verification-hook) | Teams and Enterprise |
| [Password Verification Attempt](https://supabase.com/docs/guides/auth/auth-hooks/password-verification-hook) | Teams and Enterprise |

Supabase supports 2 ways to [configure a hook](https://supabase.com/dashboard/project/_/auth/hooks) in your project:

Postgres Function  
HTTP Endpoint

A [Postgres function](https://supabase.com/docs/guides/database/functions) can be configured as a hook. The function should take in a single argument \-- the event of type JSONB \-- and return a JSONB object. Since the Postgres function runs on your database, the request does not leave your project's instance.

## Security model[\#](https://supabase.com/docs/guides/auth/auth-hooks#security-model)

Sign the payload and grant permissions selectively in order to guard the integrity of the payload.

SQL  
HTTP

When you configure a Postgres function as a hook, Supabase will automatically apply the following grants to the function for these reasons:

* Allow the supabase\_auth\_admin role to execute the function. The supabase\_auth\_admin role is the Postgres role that is used by Supabase Auth to make requests to your database.  
* Revoke permissions from other roles (e.g. anon, authenticated, public) to ensure the function is not accessible by Supabase Data APIs.

*\-- Grant access to function to supabase\_auth\_admin*

grant execute

 on function public.custom\_access\_token\_hook

 to supabase\_auth\_admin;

*\-- Grant access to schema to supabase\_auth\_admin*

grant usage on schema public to supabase\_auth\_admin;

*\-- Revoke function permissions from authenticated, anon and public*

revoke execute

 on function public.custom\_access\_token\_hook

 from authenticated, anon, public;

You will need to alter your row-level security (RLS) policies to allow the supabase\_auth\_admin role to access tables that you have RLS policies on. You can read more about RLS policies [here](https://supabase.com/docs/guides/database/postgres/row-level-security).

Alternatively, you can create your Postgres function via the dashboard with the security definer tag. The security definer tag specifies that the function is to be executed with the privileges of the user that owns it.

Currently, functions created via the dashboard take on the postgres role. Read more about the security definer tag [in our database guide](https://supabase.com/docs/guides/database/functions#security-definer-vs-invoker)

## Using Hooks[\#](https://supabase.com/docs/guides/auth/auth-hooks#using-hooks)

### Developing[\#](https://supabase.com/docs/guides/auth/auth-hooks#developing)

Let us develop a Hook locally and then deploy it to the cloud. As a recap, here’s a list of available Hooks

| Hook | Suggested Function Name | When it is called | What it Does |
| ----- | ----- | ----- | ----- |
| Send SMS | send\_sms | Each time an SMS is sent | Allows you to customize message content and SMS Provider |
| Send Email | send\_email | Each time an Email is sent | Allows you to customize message content and Email Provider |
| Custom Access Token | custom\_access\_token | Each time a new JWT is created | Returns the claims you wish to be present in the JWT. |
| MFA Verification Attempt | mfa\_verification\_attempt | Each time a user tries to verify an MFA factor. | Returns a decision on whether to reject the attempt and future ones, or to allow the user to keep trying. |
| Password Verification Attempt | password\_verification\_attempt | Each time a user tries to sign in with a password. | Return a decision whether to allow the user to reject the attempt, or to allow the user to keep trying. |

Edit config.toml to set up the Auth Hook locally.

SQL  
HTTP

Modify the auth.hook.\<hook\_name\> field and set uri to a value of pg-functions://postgres/\<schema\>/\<function\_name\>

\[auth.hook.\<hook\_name\>\]

enabled \= true

uri \= "pg-functions://...."

You need to assign additional permissions so that Supabase Auth can access the hook as well as the tables it interacts with.

The supabase\_auth\_admin role does not have permissions to the public schema. You need to grant the role permission to execute your hook:

grant execute

 on function public.custom\_access\_token\_hook

 to supabase\_auth\_admin;

You also need to grant usage to supabase\_auth\_admin:

grant usage on schema public to supabase\_auth\_admin;

Also revoke permissions from the authenticated and anon roles to ensure the function is not accessible by Supabase Serverless APIs.

revoke execute

 on function public.custom\_access\_token\_hook

 from authenticated, anon;

For security, we recommend against the use the security definer tag. The security definer tag specifies that the function is to be executed with the privileges of the user that owns it. When a function is created via the Supabase dashboard with the tag, it will have the extensive permissions of the postgres role which make it easier for undesirable actions to occur.

We recommend that you do not use any tag and explicitly grant permissions to supabase\_auth\_admin as described above.

Read more about security definer tag [in our database guide](https://supabase.com/docs/guides/database/functions#security-definer-vs-invoker).

Once done, save your Auth Hook as a migration in order to version the Auth Hook and share it with other team members. Run [supabase migration new](https://supabase.com/docs/reference/cli/supabase-migration-new) to create a migration.

If you're using the Supabase SQL Editor, there's an issue when using the ? (*Does the string exist as a top-level key within the JSON value?*) operator. Use a direct connection to the database if you need to use it when defining a function.

Here is an example hook signature:

create or replace function public.custom\_access\_token\_hook(event jsonb)

returns jsonb

language plpgsql

as $$

declare

 *\-- Insert variables here*

begin

 *\-- Insert logic here*

 return event;

end;

$$;

You can visit SQL Editor \> Templates for hook templates.

### Deploying[\#](https://supabase.com/docs/guides/auth/auth-hooks#deploying)

In the dashboard, navigate to [Authentication \> Hooks](https://supabase.com/dashboard/project/_/auth/hooks) and select the appropriate function type (SQL or HTTP) from the dropdown menu.

### Error handling[\#](https://supabase.com/docs/guides/auth/auth-hooks#error-handling)

You should return an error when facing a runtime error. Runtime errors are specific to your application and arise from specific business rules rather than programmer errors.

Runtime errors could happen when:

* The user does not have appropriate permissions  
* The event payload received does not have required claims.  
* The user has performed an action which violates a business rule.  
* The email or phone provider used in the webhook returned an error.

SQL  
HTTP

The error is a JSON object and has the following properties:

* error An object that contains information about the error.  
  * http\_code A number indicating the HTTP code to be returned. If not set, the code is HTTP 500 Internal Server Error.  
  * message A message to be returned in the HTTP response. Required.

Here's an example:

{

 "error": {

   "http\_code": 429,

   "message": "You can only verify a factor once every 10 seconds."

 }

}

Errors returned from a Postgres Hook are not retry-able. When an error is returned, the error is propagated from the hook to Supabase Auth and translated into a HTTP error which is returned to your application. Supabase Auth will only take into account the error and disregard the rest of the payload.

Outside of runtime errors, both HTTP Hooks and Postgres Hooks return timeout errors. Postgres Hooks have 2 seconds to complete processing while HTTP Hooks should complete in 5 seconds. Both HTTP Hooks and Postgres Hooks are run in a transaction do limit the duration of execution to avoid delays in authentication process.

# Custom Access Token Hook

## Customize the access token issued by Supabase Auth

---

The custom access token hook runs before a token is issued and allows you to add additional claims based on the authentication method used.

Claims returned must conform to our specification. Supabase Auth will check for these claims after the hook is run and return an error if they are not present.

These are the fields currently available on an access token:

Required Claims: iss, aud, exp, iat, sub, role, aal, session\_id, email, phone, is\_anonymous

Optional Claims: jti, nbf, app\_metadata, user\_metadata, amr,

Inputs

| Field | Type | Description |
| ----- | ----- | ----- |
| user\_id | string | Unique identifier for the user attempting to sign in. |
| claims | object | Claims which are included in the access token. |
| authentication\_method | string | The authentication method used to request the access token. Possible values include: oauth, password, otp, totp, recovery, invite, sso/saml, magiclink, email/signup, email\_change, token\_refresh, anonymous. |

JSON  
JSON Schema

{

 "user\_id": "8ccaa7af-909f-44e7-84cb-67cdccb56be6",

 "claims": {

   "aud": "authenticated",

   "exp": 1715690221,

   "iat": 1715686621,

   "sub": "8ccaa7af-909f-44e7-84cb-67cdccb56be6",

   "email": "",

   "phone": "",

   "app\_metadata": {},

   "user\_metadata": {},

   "role": "authenticated",

   "aal": "aal1",

   "amr": \[ { "method": "anonymous", "timestamp": 1715686621 } \],

   "session\_id": "4b938a09-5372-4177-a314-cfa292099ea2",

   "is\_anonymous": true

 },

 "authentication\_method": "anonymous"

}

Outputs

Return these only if your hook processed the input without errors.

| Field | Type | Description |
| ----- | ----- | ----- |
| claims | object | The updated claims after the hook has been run. |

SQL  
HTTP

Minimal JWT

Add admin role

Restrict access to SSO users

Sometimes the size of the JWT can be a problem especially if you're using a [Server-Side Rendering framework](https://supabase.com/docs/guides/auth/server-side). Common situations where the JWT can get too large include:

* The user has a particularly large name, email address or phone number  
* The default JWT has too many claims coming from OAuth providers  
* A large avatar URL is included

To lower the size of the JWT you can define a Custom Access Token hook like the one below which will instruct the Auth server to issue a JWT with only the listed claims. Check the documentation above on what JWT claims must be present and cannot be removed.

Refer to the [Postgres JSON functions](https://www.postgresql.org/docs/current/functions-json.html) on how to manipulate jsonb objects.

create or replace function public.custom\_access\_token\_hook(event jsonb)

returns jsonb

language plpgsql

as $$

 declare

   original\_claims jsonb;

   new\_claims jsonb;

   claim text;

 begin

   original\_claims \= event-\>'claims';

   new\_claims \= '{}'::jsonb;

   foreach claim in array array\[

     *\-- add claims you want to keep here*

     'iss',

     'aud',

     'exp',

     'iat',

     'sub',

     'role',

     'aal',

     'session\_id',

     'email',

     'phone',

     'is\_anonymous'

  \] loop

     if original\_claims ? claim then

       *\-- original\_claims contains one of the listed claims, set it on new\_claims*

       new\_claims \= jsonb\_set(new\_claims, array\[claim\], original\_claims\-\>claim);

     end if;

   end loop;

   return jsonb\_build\_object('claims', new\_claims);

 end

$$;  
